<html>
  <head>
    <title>INFO 4310 - Final Project</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://github.com/1wheel/graph-scroll/blob/gh-pages/graph-scroll.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap">
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="https://d3js.org/d3-hexbin.v0.2.min.js"></script>

    <style>
      /* CSS FOR STRUCTURE, TEXT */
        html, body {
            margin: 0;
            padding: 0;
        }

        body, button {
          font-family: 'Lato', sans-serif;
        }

        p {
          line-height: 1.75;
        }

        /* CSS FOR MAP */

        #map-container { 
          height: 48%;
          width: 100%; 
          background-color: rgb(233, 233, 233);
        }

        #map {
          height: 100%;
          width: 100%;
        }

        .boundary {
          fill: white;
          stroke: #c3c3c3;
          stroke-width: 1px;
        }

        .hexagons path {
          shape-rendering: optimizeSpeed;
        }

        /* CSS FOR MAP LEGEND */

        #legend-container {
          height: 1%;
          width: 100%;
        }

        #legend {
          height: 100%;
          width: 100%;
        }

        #legend-labels {
          display: flex;
          justify-content: space-between;
          padding: 0 2px 0 5px;
          font-size: 0.85em;
          color: gray;
        }
      
        /* CSS FOR SCROLLED COMPONENTS */

        #part1-main{
          /* display: flex;
          flex-direction: row; */
          position: sticky;
          top: 0px;
        }
        
        #part1-left{
          height: 1000px;
          /* display: flex; */
          /* flex-direction: row; */
          /* flex-direction: column; */
          padding-top: 1em;
          width: 50%;
          position: sticky;
          top: 0px;
        }

        #part1-right{
          width: 100%;
          text-align: center;
          
        }

        #barchart {
          width: 100%;
        }
        
        #barchart_div{
          /* width: 50%; */
          padding-top: 1em;
          text-align: center;
        }

        h1{
          margin-top: 10px;
        }

        .part1, #part2-text{
          width: 80%;
          margin: 0 auto;
          text-align: center;
          margin-bottom: 10px;
        }

        #part2-text{
          /* how much space do you need between the last bar annotation and part 2 */
          margin-top: 300px;
        }

        #part2{
          position: relative;
          top: -800px; 
          /* margin-top:300px; */
          background-color: white;
          z-index: 2;
          width: 50%;
          margin-left:50%;
          /* padding-top: 10px; */
          
        }

        #part2-main{
          display:flex;
          flex-direction:row;
          justify-content: center;
          align-items: center;
        }

      /* CSS FOR D3 VISUALIZATIONS */

        .gridlines .domain {
          display: none;
        }
        
        .gridlines line {
          stroke: #d5d5d5;
        }

        .scrolled {
          stroke-width:2;
          stroke:rgb(0,0,0)
        }

        /* .hideAnnotation{
          display: none;
        } */
        
      

    </style>
  </head>

  <body>
    <main>
      <div class="part1">
        <h1>The Effects of Warming Ocean Temperatures and La Ni&#241a on the 2024 East Coast Hurricane Season</h1>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus a lacus feugiat, laoreet ipsum pharetra, vulputate ligula. Donec dapibus posuere dolor, non pellentesque sem efficitur gravida. In neque urna, mattis non accumsan vitae, euismod eget dolor. Duis bibendum purus sed sodales tristique. Suspendisse faucibus nibh orci, sed rhoncus turpis bibendum ac. Etiam sit amet volutpat neque. Sed auctor luctus tortor. Fusce at posuere est, quis sagittis est. Fusce in ullamcorper nisl. Interdum et malesuada fames ac ante ipsum primis in faucibus.
          In sit amet felis lorem. Curabitur cursus nulla magna. Vivamus a nulla sit amet tortor tincidunt sollicitudin quis aliquam massa. Praesent leo ante, tristique in vestibulum eget, sagittis in metus. Nulla varius nulla et feugiat laoreet. Nunc feugiat sollicitudin sem, non varius ligula. Aliquam sit amet ligula libero. Sed tincidunt diam leo, in porta lorem cursus nec. Aenean faucibus tristique neque vitae egestas. Pellentesque viverra dui ut urna fringilla, non tincidunt felis volutpat. Aliquam erat volutpat. Pellentesque ultrices ut nibh ut facilisis. Aenean in quam nec neque porta condimentum sed sit amet orci.
        </p>
      </div>
      <div id="everything_belowintro">
      <!-- <div id="sticky-wrapper"> -->
        <!-- <div id="part1-main"> -->
          <div id="part1-left">
            <h2 class="part1">Rising Ocean Temperatures and Tropical Cyclone Frequency/Intensity</h2>
            <div id="map-container">
              <svg id="map"></svg>
            </div>
            <div id="legend-container">
              <div id="legend-labels">
                <span id="min-value">-2&deg;F</span>
                <span id="mid-value">Divergence from 1971-2000 Average</span>
                <span id="max-value">2&deg;F</span>
              </div>
              <svg id="legend"></svg>
            </div>
            <div id="barchart_div">
              <svg id="barchart" height="180" width="750" style="margin-top:0px" >
              </svg>
            </div>
          </div> <!--close part1-left (flexbox columns)-->
        <!-- </div> close part1-main (flexbox rows) -->
      <!-- </div> close wrapper (sticky) -->
      <div id="part2">
        <div id="part1-right"> 
        </div>
        <div id="part2-text">
          <h2>La Ni&#241a Season Approaches...</h2>
          <p style="font-style: italic;">
            "NOAA's most recent forecasts predict 80% chance of La Nina conditions during this year's hurricane season + in combination with record-breaking ocean temps, this hurricane season is highly likely to be unprecedented."
          </p>
          <p> 
            La Ni&#241a refers to the periodic cooling of ocean surface temperatures in the central and east-central equatorial Pacific. This weakens vertical wind sheer and trade winds in the 
            Atlantic, where tropical storms and hurricanes that hit the eastern United States develop. Less atmospheric stability means that the east coast experiences more hurricanes during La Ni&#241a 
            than during El Ni&#241o.
            
          </p>
        </div>
        <div id="part2-main">
          <svg id="linechart" height="300" width="800" style="margin-top:0px" ></svg>
        </div>
        <div id="part2-text">
          <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus a lacus feugiat, laoreet ipsum pharetra, vulputate ligula. Donec dapibus posuere dolor, non pellentesque sem efficitur gravida. In neque urna, mattis non accumsan vitae, euismod eget dolor. Duis bibendum purus sed sodales tristique. Suspendisse faucibus nibh orci, sed rhoncus turpis bibendum ac. Etiam sit amet volutpat neque. Sed auctor luctus tortor. Fusce at posuere est, quis sagittis est. Fusce in ullamcorper nisl. Interdum et malesuada fames ac ante ipsum primis in faucibus.
            In sit amet felis lorem. Curabitur cursus nulla magna. Vivamus a nulla sit amet tortor tincidunt sollicitudin quis aliquam massa. Praesent leo ante, tristique in vestibulum eget, sagittis in metus. Nulla varius nulla et feugiat laoreet. Nunc feugiat sollicitudin sem, non varius ligula. Aliquam sit amet ligula libero. Sed tincidunt diam leo, in porta lorem cursus nec. Aenean faucibus tristique neque vitae egestas. Pellentesque viverra dui ut urna fringilla, non tincidunt felis volutpat. Aliquam erat volutpat. Pellentesque ultrices ut nibh ut facilisis. Aenean in quam nec neque porta condimentum sed sit amet orci.
          </p>
        </div>
      </div>
    </div> <!--close everything_belowintro-->
    </main>
  </body>

  <script>
    // handling map
    const mapSVG = d3.select("#map");
    const mapContainer = d3.select("#map-container");

    mapSVG.attr("width", mapContainer.node().offsetWidth);
    mapSVG.attr("height", mapContainer.node().offsetHeight);
    const mapWidth = mapSVG.attr("width");
    const mapHeight = mapSVG.attr("height");
    const map = mapSVG.append("g");

    // setting up legend
    const legendSVG = d3.select("#legend");
    const legendContainer = d3.select("#legend-container");

    legendSVG.attr("width", legendContainer.node().offsetWidth);
    legendSVG.attr("height", legendContainer.node().offsetHeight);
    var legendWidth = legendSVG.attr("width");
    var legendHeight = legendSVG.attr("height");

    var legendMargin = { top: 2, right: 10, bottom: 10, left: 10 };
    var legendX = legendMargin.left;
    var legendY = legendMargin.top;

    // creating linear gradient
    var defs = legendSVG.append("defs");
    var linearGradient = defs.append("linearGradient")
        .attr("id", "legendGradient")
        .attr("x1", "100%")
        .attr("y1", "0%")
        .attr("x2", "0%")
        .attr("y2", "0%");

    let geoData;
    let hexagons;
    let colorScale;
    let extent;

    const requestMap = async function() {
      const world = await d3.json("map.json");

      var boundaries = topojson.feature(world, world.objects.croppedmap);

      var projection = d3.geoMercator()
        .fitSize([mapWidth, mapHeight], boundaries);

      var path = d3.geoPath().projection(projection);

      // rescaling projection to better fit width of container
      const bounds = path.bounds(boundaries);
      const boundingBoxHeight = bounds[1][1] - bounds[0][1];
      const scaleFactor = mapWidth / (bounds[1][0] - bounds[0][0]);

      const newScale = projection.scale() * scaleFactor;
      const newHeight = boundingBoxHeight * scaleFactor;
  
      projection.scale(newScale)

      map.attr("transform", `translate(${88}, ${26})`);

      // loading in sea surface temp anomaly data
      geoData = await d3.json('ssta_aggregate.geojson');
      const filteredData = geoData.features.filter(feature => feature.properties.ssta[0] !== "");
      filteredData.forEach( d => {
        d.position = projection( [d.geometry.coordinates[0], d.geometry.coordinates[1]] );
      });

      // creating hex grid
      const hexbin = d3.hexbin()
          .x(d => d.position[0])
          .y(d => d.position[1])
          .radius(13)
          .size([mapWidth, mapHeight]);

      const bins = hexbin(filteredData);

      const sstaValues = geoData.features.flatMap(feature => feature.properties.ssta);
      extent = d3.extent(sstaValues);

      colorScale = d3.scaleDiverging().domain([-extent[0], 0, extent[0]]).interpolator(d3.interpolateRdBu);

      hexagons = map.append("g").attr("class", "hexagons")
          .selectAll("path")
          .data(bins)
          .enter().append("path")
          .attr("transform", d => `translate(${d.x},${d.y})`)
          .attr("d", hexbin.hexagon())
          .attr("fill", bin => colorScale(d3.mean(bin, d => d.properties.ssta[0])))
          .lower();

      // adding map boundaries
      map.append("g")
        .selectAll("path.boundary").data(boundaries.features)
        .join("path")
        .attr("class", "boundary")
        .attr("d", path)
        .raise(); 

      // creating legend
      linearGradient.append("stop")
        .attr("offset", "0%")
        .attr("stop-color", colorScale(-extent[0])); 
      linearGradient.append("stop")
        .attr("offset", "12.5%")
        .attr("stop-color", colorScale(-3 * extent[0] / 4));
      linearGradient.append("stop")
        .attr("offset", "25%")
        .attr("stop-color", colorScale(-extent[0] / 2)); 
      linearGradient.append("stop")
        .attr("offset", "37.5%")
        .attr("stop-color", colorScale(-extent[0] / 4));
      linearGradient.append("stop")
        .attr("offset", "50%")
        .attr("stop-color", "white"); 
      linearGradient.append("stop")
        .attr("offset", "62.5%")
        .attr("stop-color", colorScale(extent[0] / 4));
      linearGradient.append("stop")
        .attr("offset", "75%")
        .attr("stop-color", colorScale(extent[0] / 2)); 
      linearGradient.append("stop")
        .attr("offset", "87.5%")
        .attr("stop-color", colorScale(3 * extent[0] / 4));
      linearGradient.append("stop")
        .attr("offset", "100%")
        .attr("stop-color", colorScale(extent[0]));

      // applying gradient
      var legend = legendSVG.append("rect")
        .attr("x", legendX)
        .attr("y", legendY)
        .attr("width", legendWidth)
        .attr("height", legendHeight)
        .style("fill", "url(#legendGradient)");
    }
    requestMap();

    const updateMap = (decade) => {
      decade = Math.max(0, Math.min(17, decade));
      if (hexagons) {
        hexagons.transition().duration(50)
        .attr("fill", bin => colorScale(d3.mean(bin, d => d.properties.ssta[decade])));
      }
    };

    // generating bar charts and scroll functionality
    const requestData = async function() {
      const hurricane_frequency = await d3.csv("hf_decade_avg.csv", d3.autoType);

      // Set up the bar chart 
      console.log(hurricane_frequency)
      const bar_svg = d3.select("svg#barchart");
      const b_width = bar_svg.attr("width");
      const b_height = bar_svg.attr("height");
      const margin = {top: 30, right: 150, bottom: 50, left: 50};
      const b_chartWidth = b_width - margin.left - margin.right;
      const b_chartHeight = b_height - margin.top - margin.bottom;
      let annotations = bar_svg.append("g").attr("id","annotations");
      let chartArea = bar_svg.append("g").attr("id","bars")
                    .attr("transform",`translate(${margin.left},${margin.top})`);

      let freqExtent = d3.extent(hurricane_frequency, d=>(d['Tropical Storms']+d['Hurricanes']+d['Major Hurricanes']))
      let freqScale = d3.scaleLinear().domain([0,freqExtent[1]]).range([b_chartHeight, 0]);
      let leftAxis = d3.axisLeft(freqScale);
      let leftGridlines = d3.axisLeft(freqScale)
                            .tickSize(-b_chartWidth-10)
                            .tickFormat("")
      annotations.append("g")
                .attr("class", "y axis")
                .attr("transform",`translate(${margin.left-10},${margin.top})`)
                .call(leftAxis)
      annotations.append("g")
                .attr("class", "y gridlines")
                .attr("transform",`translate(${margin.left-10},${margin.top})`)
                .call(leftGridlines);

      const years = d3.map(hurricane_frequency, d => d.Year) 
      let yearScale = d3.scaleBand().domain(years).range([0, b_chartWidth]).padding(0.05);
      let bottomAxis = d3.axisBottom(yearScale).tickFormat(d3.format('.0f'));

      annotations.append("g")
                .attr("class", "x axis")
                .attr("transform",`translate(${margin.left},${b_chartHeight+margin.top+10})`)
                .call(bottomAxis)
                .selectAll("text")
                .attr("y", 12)
                .attr("x", -10)
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end");

      let subgroups = hurricane_frequency.columns.slice(1);
      let colorScale = d3.scaleOrdinal()
                          .domain(subgroups)
                          .range(['#e41a1c','#377eb8','#4daf4a'])

      let stackedData = d3.stack()
                          .keys(subgroups)(hurricane_frequency);
      console.log(stackedData)
      chartArea.append("g")
          .selectAll("g")
          .attr("transform",`translate(${margin.left},${b_chartHeight+margin.top+10})`)
          // Enter in the stack data = loop key per key = group per group
          .data(stackedData)
          .enter().append("g")
            .attr("fill", function(d) { return colorScale(d.key); })
            .selectAll(`rect`)
            // enter a second time = loop subgroup per subgroup to add all rectangles
            .data(function(d) { return d; })
            .enter().append("rect")
              .attr("x", d => { return yearScale(d.data.Year); })
              .attr("y", d=> { return freqScale(d[1]); })
              .attr("height", d=> { return freqScale(d[0]) - freqScale(d[1]); })
              .attr("width", yearScale.bandwidth())
              .attr("id", d=>`year${d.data.Year}`)

      //add title
      annotations.append('text')
                .text('Frequency of Hurricanes by Decade')
                .attr('x',  (b_chartWidth-margin.right)/2)
                .attr('y', margin.top)
                .style("font-size", "15px")
                .style('font-weight', 'bold')

      //add legend
      annotations.append('rect')
                .attr('x', b_chartWidth+margin.right*(2/3)-25)
                .attr('y', b_chartHeight/3-20)
                .attr('width', 20)
                .attr('height', 20)
                .attr('stroke', colorScale('Tropical Storms'))
                .attr('fill', colorScale('Tropical Storms'));
      annotations.append('text')
                .text('Tropical Storms')
                .attr('x',  b_chartWidth+margin.right*(2/3))
                .attr('y', b_chartHeight/3)
                .style("font-size", "12px")
                .style('font-weight', 'bold');
      annotations.append('rect')
                .attr('x', b_chartWidth+margin.right*(2/3)-25)
                .attr('y', b_chartHeight/3-20+30)
                .attr('width', 20)
                .attr('height', 20)
                .attr('stroke', colorScale('Hurricanes'))
                .attr('fill', colorScale('Hurricanes'));
      annotations.append('text')
                .text('Hurricanes')
                .attr('x',  b_chartWidth+margin.right*(2/3))
                .attr('y', b_chartHeight/3+30)
                .style("font-size", "12px")
                .style('font-weight', 'bold');
      annotations.append('rect')
                .attr('x', b_chartWidth+margin.right*(2/3)-25)
                .attr('y', b_chartHeight/3-20+60)
                .attr('width', 20)
                .attr('height', 20)
                .attr('stroke', colorScale('Major Hurricanes'))
                .attr('fill', colorScale('Major Hurricanes'));
      annotations.append('text')
                .text('Major Hurricanes')
                .attr('x',  b_chartWidth+margin.right*(2/3))
                .attr('y', b_chartHeight/3+60)
                .style("font-size", "12px")
                .style('font-weight', 'bold');


      //list of all my annotations i want to display
      let textpopups = {1:['CALLOUT BAR 1', 'Template callout'], 
        6:['Title2 (BAR 6)', 'The 1910s saw a decrease in hurricane frequency, though 4 of the top 15 most deadly Mainland U.S tropical cyclones are from this decade.'], 
        13:['Title3 (BAR 13)', 'After the 1980s, the increase in average ocean temperatures has consistently been above the century average.']}

      let prev_t = 0
      for(t in textpopups){
        // console.log('here')
        d3.select('#part1-right').append('div').attr('id', `popup${t}`).style('margin-top', (t-prev_t)*100-50)
        // above creates margin based on distance from prev popup, also removing 50 pixels for how long the prev text probably was
        current_popup = d3.select(`#popup${t}`)
        current_popup.append('h2').text(textpopups[t][0])
        current_popup.append('p').text(textpopups[t][1])
        prev_t=t //keep track of previous t so the margins dont get too big
      }

      //mapping of year to "bar-number" bc im stupid. 
      // like i have the barchart IDs as year1850 but the scroll works based on bar-number so. this is my solution
      let yearBarMapping = {}
      let yearCounter = 1850;
      let i=0;
      while (yearCounter<=2020){
        yearBarMapping[i] = `year${yearCounter}`;
        i=i+1;
        yearCounter = yearCounter+10;
      }
                    
      // Bar chart highlights based on scroll
      let lastScrollPosition = 0;

      window.onload = function() {
        window.scrollTo(0, 5000); //automatically make the page really long, this helps with smoother scrolling
        window.scrollTo(0, 200); //bring user back to the top
      };

      //create a function to update the annotation box of the bar chart
      // function annotationUpdate(barNumber, annotationText){
      //   console.log('in here', annotationText)
      //   d3.select('#annotation-title').text(annotationText[0]).classed('hideAnnotation', false).classed('displayAnnotation', true);
      //   d3.select('#annotation-text').text(annotationText[1]).classed('hideAnnotation', false).classed('displayAnnotation', true);
      // }

      window.addEventListener('scroll', function() {
        var scrolled = window.scrollY;
        console.log(scrolled)

        //can adjust this. if you change this, change for t in textpopups section
        bar_number = Math.floor((scrolled-250)/100);
        
        d3.selectAll(`rect`).attr('class', '')
        let current_year = years[bar_number]

        let current_bars = chartArea.selectAll(`#year${current_year}`)
        current_bars.attr('class', 'scrolled')

        
        // if(bar_number in textpopups){
        //   annotationUpdate(bar_number, textpopups[bar_number])
        // }
        // else{
        //   d3.select('#annotation-title').attr("class", "hideAnnotation");
        //   d3.select('#annotation-text').attr("class", "hideAnnotation");
        // }

        updateMap(bar_number);

        //dynamically add more pixels to the page -- DON'T REALLY NEED THIS IF YOU HAVE window.scrollTo(0, BIG NUMBER) ON LOAD!
        // var content = d3.select('main');
        // if (scrolled === 0) {
        //   content.style('height', content.node().offsetHeight + 2 + 'px');
        //   window.scrollBy(0, 1); // Scroll down slightly to prevent immediate recall
        // } else if (scrolled + window.innerHeight >= content.node().offsetHeight) {
        //   content.style('height', content.node().offsetHeight + 2 + 'px'); 
        // }
        // lastScrollPosition = scrolled;
      });   
      
      // PART 2
      const oni_data = await d3.csv("oni.csv", d3.autoType);
      const hurricane_freq_yearly = await d3.csv("hurricane_frequency_cut.csv", d3.autoType);
      console.log(hurricane_freq_yearly)

      //set up bars
      const linechart = d3.select('svg#linechart')
      const l_width = linechart.attr("width");
      const l_height = linechart.attr("height");
      const l_margin = {top: 10, right: 150, bottom: 50, left: 50};
      const l_chartWidth = l_width - l_margin.left - l_margin.right;
      const l_chartHeight = l_height - l_margin.top - l_margin.bottom;
      let l_annotations = linechart.append("g").attr("id","annotations");
      let l_chartArea = linechart.append("g").attr("id","bars")
                    .attr("transform",`translate(${l_margin.left},${l_margin.top})`);

      const valueExtent = d3.extent(oni_data, d => d['Value']);
      const valueScale = d3.scaleLinear().domain(valueExtent).range([l_chartHeight, 0]);

      const l_yearExtent = d3.extent(oni_data, d=>d['Season']);
      const l_yearScale = d3.scaleLinear().domain(l_yearExtent).range([0,l_chartWidth]);
      let l_leftAxis = d3.axisLeft(valueScale).ticks(7);
      let l_leftGridlines = d3.axisLeft(valueScale)
                            .tickSize(-l_chartWidth-10)
                            .tickFormat("").ticks(7)
      l_annotations.append("g")
                .attr("class", "y axis")
                .attr("transform",`translate(${l_margin.left-10},${l_margin.top})`)
                .call(l_leftAxis);

      let l_bottomAxis = d3.axisBottom(l_yearScale).tickFormat(d3.format('.0f')).ticks(40);
      
      l_annotations.append("g")
                .attr("class", "x axis")
                .attr("transform",`translate(${l_margin.left},${l_chartHeight+l_margin.top+10})`)
                .call(l_bottomAxis)
                .selectAll("text")
                .attr("y", 12)
                .attr("x", -10)
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end");

      
      l_chartArea.append("line")
             .attr("class","zeroline")
             .attr("x1", -10)
             .attr("x2", l_chartWidth+10)
             .attr("y1", valueScale(0))
             .attr("y2", valueScale(0))
             .attr("stroke", 'black');


      //set up linechart axis (right)
      const l_freqExtent = d3.extent(hurricane_freq_yearly, d => d['Total']);
      let avg_hurricanes =  d3.mean(hurricane_freq_yearly, d => d.Total);
      const l_freqScale = d3.scaleLinear().domain([-avg_hurricanes,avg_hurricanes*2+10]).range([l_chartHeight, 0]);
      let l_rightAxis = d3.axisRight(l_freqScale);
      let l_rightGridlines = d3.axisRight(l_freqScale)
                            .tickSize(-l_chartWidth-10)
                            .tickFormat("");

      l_annotations.append("g")
                .attr("class", "y axis")
                .attr("transform",`translate(${l_chartWidth+l_margin.right-100+10},${l_margin.top})`)
                .call(l_rightAxis);

      //populate the chart with bars
      oni_data.forEach(d=>{
        l_chartArea.append('line')
                  .attr("x1", l_yearScale(d.Season))
                  .attr("x2", l_yearScale(d.Season))
                  .attr("y1", valueScale(0))
                  .attr("y2", valueScale(d.Value))
                  .attr("stroke", ((d.Value>0) ? 'red' : 'blue'))
                  .attr('stroke-width', '5px');
      })

      l_chartArea.append('line')
                  .attr("x1", -10)
                  .attr("x2", l_chartWidth+40)
                  .attr("y1", l_freqScale(d3.mean(hurricane_freq_yearly, d => d.Total)))
                  .attr("y2", l_freqScale(d3.mean(hurricane_freq_yearly, d => d.Total)))
                  .attr("stroke", 'gray')
                  .attr('stroke-width', '2px')
      l_chartArea.append('text')
                .attr('x',  l_chartWidth+45)
                .attr('y', l_freqScale(d3.mean(hurricane_freq_yearly, d => d.Total)))
                .text(`Average: ${d3.format(".1f")(d3.mean(hurricane_freq_yearly, d => d.Total),2)}`)
                .style("font-size", "11px");

      //populate the chart with lines 
      let lineGen = d3.line()
                  .x( d => l_yearScale(d['Year']) )
                  .y( d => l_freqScale(d['Total']) )
                  .curve(d3.curveMonotoneX);
      l_chartArea.append("path")
           .datum(hurricane_freq_yearly)
           .attr("class", "line")
           .attr("fill", "none")
           .attr("stroke", "black")
           .attr("stroke-width", 3)
           .attr("d", lineGen);
    }

    requestData();
  </script>
</html>